# Council Review: satoshi — PR #11
_Reviewed on 2026-02-22 03:57 UTC_

# Code Review: solana_monitor.py Error Handling

## Trust Audit

This change asks users to trust that:
1. Error handling paths behave correctly without explicit verification
2. Fallback behaviors (empty dict on failure) don't silently corrupt state
3. Atomic writes actually prevent partial file corruption
4. Logging errors is sufficient observability

The first risk is real. When `load_previous_snapshot()` returns `{}` after a corrupted file, the downstream code doesn't know if this is "no previous state" or "previous state lost." This conflates two error cases. That's dangerous.

## Minimalism Check

Good instincts here—the PR adds error handling, not bloat. But several additions are unnecessary:

- **Atomic writes with temp files**: Solana monitoring is not safety-critical. The benefit of crash-safe writes doesn't justify the complexity. Python's `path.write_text()` is atomic on most filesystems for small files anyway. This is premature hardening.

- **Try-except granularity**: Six separate try-except blocks across the diff. Some could be collapsed. Some are reasonable, some are defensive theater.

- **Import reorganization**: Bundled with the actual fix but unrelated. Split this out.

The core idea—handle JSON decode and IO errors—is sound. The execution adds machinery.

## Privacy & Security Assessment

No privacy leakage here. Error messages are contextual, not overly verbose. Logs don't expose wallet addresses or token amounts in the visible diff. That's correct.

Security: The silent fallback to `{}` when state is corrupted is **the real issue**. If a previous snapshot is corrupted or lost, the monitoring will report everything as a change. This could trigger false alerts, alert fatigue, or worse—loss of actual alerts in noise. Not cryptographically broken, but logically broken.

## The Problem

This PR treats symptoms, not causes:

1. **Symptom**: Code crashes on malformed JSON
2. **Proposed fix**: Catch exception, return empty dict
3. **Real problem**: You're now silent about data loss. Silent failure is the root problem you said you opposed.

Better approach: fail loudly and explicitly. If a snapshot is corrupted, stop and alert. Don't pretend it's missing. The operator needs to know. Let them decide if recovery is possible.

The fallback behavior—`return {}`—should be explicitly labeled as "assume no previous state existed" with corresponding log level `ERROR`, not `warning`. Or better: raise a custom exception that forces the caller to handle it.

## The Verdict from the Shadows

This PR improves reliability in one dimension (crashes less) while reducing observability in another (silent data loss). It's defensive without being precise. 

The atomic write pattern is unnecessary complexity for a non-critical agent. The error handling is reasonable in principle but wrong in practice—it hides rather than surfaces failures.

The code is not broken, but it's not right either. It needs one revision: explicit distinction between "state never existed" and "state was lost," with appropriate severity levels. Make the implicit semantics explicit. Then the error handling becomes trustworthy.

VOTE: REVISE
