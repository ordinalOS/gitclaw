# Council Review: toly — PR #11
_Reviewed on 2026-02-22 03:54 UTC_

# Council Review: solana_monitor.py Error Handling
## Toly's Assessment

Alright, let me cut through this. Error handling is foundational — you can't build reliable systems on assumptions. This PR addresses a real problem: silent failures during monitoring sweeps. But the implementation has some throughput and architectural issues I need to flag.

### Throughput Analysis
**Problem:** This change introduces multiple `sys.exit(1)` calls in fallible paths. That's a hard stop.

Look at the diff:
- `load_previous_snapshot()` — exits on file read errors
- `save_snapshot()` — exits on write errors  
- `get_watched_wallets()` — exits on malformed config

In a live monitoring system, **any** of these can fail transiently — flaky disk I/O, brief permission issues, network blips on remote storage. Exiting the entire agent kills your monitoring throughput and creates cascading failures across the system.

Compare this to Solana validators: when we hit transient I/O or network errors, we retry and backoff. We don't nuke the entire validator. This is the same principle.

### Parallelism Audit
The sequential structure is fine here — config loading, snapshot I/O, wallet checks are inherently sequential. No issues on that front. But the exit-on-error pattern means you lose the chance to keep monitoring *other* wallets if one fails. That's a missed opportunity.

### Crypto-Native Angle
Decentralized systems need **graceful degradation**. If one RPC is flaky, the system keeps running with partial data. If one wallet fetch fails, you continue monitoring the rest. This PR takes the opposite approach: one failure cascades.

Also, **missing error context around API calls** — the diff is truncated, but I need to see how JSON parsing errors in actual API responses are handled. Is there fallback retry logic? Exponential backoff? Or just fail hard?

### The Core Issue
The philosophy here is binary: success or die. That works for critical path operations (transaction signing, consensus), but not for monitoring sweeps. Monitoring is inherently best-effort — partial data is better than no data.

### What I'd Expect
```python
# Load snapshot with graceful fallback
try:
    state = json.loads(file.read_text())
except (json.JSONDecodeError, OSError) as e:
    log(f"⚠️  Using empty snapshot due to: {e}", level="warning")
    state = {}  # Continue, don't exit

# Fetch wallet with retry + fallback
for wallet in wallets:
    try:
        balance = fetch_balance_with_retry(wallet, max_retries=3)
    except Exception as e:
        log(f"⚠️  Failed to fetch {wallet}: {e}, skipping", level="warning")
        continue  # Move to next wallet
```

### Specific Concerns
1. **sys.exit(1) in recovery paths** — too aggressive. Demote to warnings + continue.
2. **JSON parsing on config** — should validate at startup, not in hot paths. Load once, cache, use sensible defaults.
3. **Missing retry logic** — API errors especially need backoff before giving up.
4. **Truncated diff** — can't fully assess API call error handling without seeing it.

### The Good
- Logging context is solid (includes which token/API failed)
- JSON decode errors are caught explicitly
- Defensive typing check on `get_watched_wallets()`

### Toly's Call
This PR is **well-intentioned but over-aggressive on failure modes**. It'll actually *reduce* reliability in production because transient errors will kill the monitoring agent. That's backwards.

**Fix path:** Replace hard exits with graceful degradation. Log warnings, return empty/default state, continue processing. That's how resilient systems work.

VOTE: REVISE
